<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LPW: Play with DEMOs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="tutorial-utils.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.bootcdn.net/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="lpv_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 100px;">
  <td id="projectlogo" style="padding-left: 1em; text-align: center; vertical-align: middle;"><a href="index.html"><img alt="Logo" src="lpw_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em; vertical-align: bottom; padding-bottom: 5px; ">
   <!--<div id="projectname">LPW-->
   <!--</div>-->
   <div id="projectbrief">Leaper WaferScan Toolkit</div>
   <div id="projectbrief"><a href="../../cn/html/index.html">中文</a> / <a href="../../en/html/index.html">English</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Play with DEMOs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_Z__stonewall_doc_en_t02_how_to_play_with_demo"></a> There are two kinds of DEMOs in the LPW package:</p>
<ul>
<li>MFC/C#/QT programs with GUI, providing user friendly graphics interface for interactive region manipulation, parameters' tuning and results' displacement. The executable binaries are located under the demo/require_platform folder, like demo/x64. The source codes as well as the project files are available in the individual project folder.</li>
<li>Simple C++/C# code snippets, demonstrating how some LPW functions are called. It's usually a main function body in one single source file under demo/snippet folder. For detailed usage, please refer to <a class="el" href="how_to_use_code_snippets.html">How to Use DEMO Code Snippets</a>.</li>
</ul>
<p><em>NOTE 1: The platform of DEMOs should be exactly the same as the LPW dlls you installed and registered.</em><br  />
 <em>NOTE 2: Please make sure the LPW dlls are registered and licensed before running the DEMOs.</em><br  />
 <em>NOTE 3: The out-of-box Qt DEMO executors are built with Qt5.9.4, you may install the same version from Qt's official website. Or, you may use our abridged package of only the necessary dependencies, just download(<a href="http://fileserver.hzleaper.com:8086/f/d0bca96b69ea43bbba44/">x86</a> or <a href="http://fileserver.hzleaper.com:8086/f/265acd571340457fa0d1/">x64</a>) then extract to the DEMO folder.</em></p>
<p><b>GUI DEMO</b></p>
<table class="markdownTable">
<tr>
<th class="markdownTableHeadLeft"></th><th class="markdownTableHeadLeft">Description </th></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_sanity">Sanity</a></td><td>Demonstrate a typical vision task involves Image, Region, Pattern matching, calibration modules. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_region">Region Manipulation</a></td><td>Demonstrate how to edit regions and how to calculate and create new regions. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_hikcam">Integrate with Camera</a></td><td>Demonstrate how to capture image into a LImage object with camera APIs, take Hik camera as an example. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_pat">Template Matching</a></td><td>Demonstrate template matching with sub-pixel precision. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_blob">Blob Analysis</a></td><td>Demonstrate blob analysis, either in grayscale or color mode. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_imgproc">Image Processing</a></td><td>Demonstrate the common image processing operations. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_line">Line Detection</a></td><td>Demonstrate line detection with sub-pixel precision. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_circle">Circle Detection</a></td><td>Demonstrate circle detection with sub-pixel precision. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_path">Path Detection</a></td><td>Demonstrate path detection. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_contour">Contour Detection</a></td><td>Demonstrate contour detection with sub-pixel precision. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_crossmark">Cross Mark Detection</a></td><td>Demonstrate cross mark detection with sub-pixel precision. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_gauge">Gauging</a></td><td>Demonstrate the inspection using gauge tools for various shapes. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_calib">Calibration</a></td><td>Demonstrate the camera calibration, including n-points, pin-hole, FFD camera models using different types of calibration boards. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_camarray">Camera Array and Image Stitching</a></td><td>Demonstrate the camera array calibration and image stitching. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_geom">Geometry</a></td><td>Demonstrate geometry module, including intersection calculation, gauging, fitting, etc. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_barcode">Barcode</a></td><td>Demonstrate 1D/2D barcode detection and quality verification. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_display">Display Control</a></td><td>Demonstrate the display control. </td></tr>
<tr>
<td><a class="el" href="how_to_play_with_demo.html#demo_ibservice">Connect to IntelliBlink Service</a></td><td>Demonstrate how to integrate with and make use of powerful IntelliBlink tasks. </td></tr>
</table>
<p><b>Code Snippets</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"></th><th class="markdownTableHeadLeft">Source code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>HDR</b>   </td><td class="markdownTableBodyLeft">HDR.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the HDR algorithm.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Image Blend</b>   </td><td class="markdownTableBodyLeft">ImageBlend.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the image blending algorithm which is useful for denoising.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Min-max Distance</b>   </td><td class="markdownTableBodyLeft">MinMaxDistance.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate how to measure the distance between polygons.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Projection and Analysis</b>   </td><td class="markdownTableBodyLeft">ProjectionAndAnalysis.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the image projection, and data analysis on the projection result, such as filtering, local extrema detection, etc.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Sort</b>   </td><td class="markdownTableBodyLeft">Sort.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the sorting algorithms, especially the array sorter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Color Space Conversion</b>   </td><td class="markdownTableBodyLeft">ColorSpace.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the conversion of the color images between common color spaces.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Template Matching with Customized Shape</b>   </td><td class="markdownTableBodyLeft">LearnWithShape.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate how to train the template using customized shape generated via region objects.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Rotation Calibration and Alignment</b>   </td><td class="markdownTableBodyLeft">CalibRotationCenter.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the rotation center calibration and mark alignment.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Background Subtract</b>   </td><td class="markdownTableBodyLeft">BackgroudSubtract.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the detection of moving or pop-up objects in the static scene.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Data Blob Analysis</b>   </td><td class="markdownTableBodyLeft">DataBlob.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the defect inspection on the cutting kerf, using data blob analysis.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Free Transformation of Image and Shapes</b>   </td><td class="markdownTableBodyLeft">FreeTransform.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the generation of transform using point pairs and the transformation of the image and shape objects.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Classification using Machine Learning</b>   </td><td class="markdownTableBodyLeft">MLClassification.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the image classification application using machine learning based approach.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Hand-written OCR</b>   </td><td class="markdownTableBodyLeft">OCRHandWritten.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the OCR tool, to recognize hand-written characters as an example.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Polygon Operations</b>   </td><td class="markdownTableBodyLeft">PolygonClipper.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the clipping operations to a polygon, such as expand, shrink, or boolean operations like intersection or union.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Pin Count</b>   </td><td class="markdownTableBodyLeft">PinCount.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate how to detect and count the pins, using the double-side edge gauge tool.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Flat Field Calibration using a White Board</b>   </td><td class="markdownTableBodyLeft">FlatFieldWhiteBoard.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the flat field calibration process using a white board, to remove shading and lens cast.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Flat Field Calibration using a Solar Cell</b>   </td><td class="markdownTableBodyLeft">FlatFieldSolar.cpp/cs   </td><td class="markdownTableBodyLeft">Demonstrate the flat field calibration process using the actual inspection object   </td></tr>
</table>
<p><br  />
</p>
<hr  />
<p>The followings are the introduction to the GUI DEMOs.</p>
<h1><a class="anchor" id="demo_sanity"></a>
Sanity</h1>
<p>Demonstrate a typical vision task involves Image, Region, Pattern matching, calibration modules.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCSanity<br  />
 <b>Source code (Qt):</b> qtdemo/QtSanity<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpSanity<br  />
 <b>Image files:</b> sourceImg.png, templateImg.png</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">LImage</a>, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_rect_region.html">LRectRegion</a>, <a class="el" href="interface_l_p_v_pat_lib_1_1_i_l_match.html">LMatch</a>, <a class="el" href="interface_l_p_v_pat_lib_1_1_i_l_match_results.html">LMatchResults</a>, <a class="el" href="interface_l_p_v_calib_lib_1_1_i_l_calib_n_points.html">LCalibNPoints</a> </p>
</blockquote>
<p><a href="t02_01_sanity.png"><img src="t02_01_sanity.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load the image from file.</li>
<li>Click <b>Template Learn</b> button, learn template from current image and region.</li>
<li>Click <b>Template Match</b> button, do pattern matching in current region. The detect result's pixel position shows on the right.</li>
<li>Click <b>Calibrate</b> button, do calibration with 9 points. Now the detect result's world position is displayed on the right.</li>
<li>Click <b>Reset Calibration</b> button, reset calibration. Now the detect result's pixel position is displayed on the right.</li>
<li>Click <b>Save Calibration</b> button, save current calibration object to file.</li>
<li>Click <b>Load Calibration</b> button, load a new calibration object from file.</li>
<li>Click <b>Copy &amp; Save</b> button, save the current image to jpg file. You can find the saved image under same folder as the DEMO exe.</li>
<li>Drag the handles of the region, move or resize the region.</li>
<li>Click <b>Reset Roi</b> button, reset region's placement according to current image size.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_region"></a>
Region Manipulation</h1>
<p>Demonstrate how to edit regions and how to calculate and create new regions.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCRegion<br  />
 <b>Source code (Qt):</b> qtdemo/QtRegion<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpRegion<br  />
 <b>Image files:</b> mask.bmp</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_rect_region.html">LRectRegion</a>, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_rot_rect_region.html">LRotRectRegion</a>, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_poly_region.html">LPolyRegion</a>, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_mask_region.html">LMaskRegion</a>, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_circle_region.html">LCircleRegion</a>, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_annulus_region.html">LAnnulusRegion</a> </p>
</blockquote>
<p><a href="t02_13_region.png"><img src="t02_13_region.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>Click <b>Load Mask</b> button, load mask image to the mask region.</li>
<li>Select the proper <b>R1</b> and <b>R2</b> region, for the further manipulation.</li>
<li>Click the manipulation buttons, and check the result region on the canvas.</li>
<li>The demo application does <b>Union</b>, <b>Subtract</b>, <b>Intersect</b>, or <b>Exclusive OR</b> of the select R1 and R2 region.</li>
<li>The demo application does <b>Translation</b>, <b>Rotate</b>, <b>Scale</b> or <b>Invert</b> the R1 region, using the input <b>dx</b>, <b>dy</b>, <b>da</b> and <b>ds</b> value.</li>
<li>Click <b>Reduce Image</b>, the R1 region's reduced image and mask is shown on the canvas.</li>
<li>Click <b>To Mask</b>, the R1 region's mask is show on the canvas.</li>
<li>Move the cursor on the canvas will show the pixel under the cursor and its relative position in R1 region.</li>
<li>Click <b>Back to Edit</b> to return the original state.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_hikcam"></a>
Integrate with Camera</h1>
<p>Demonstrate how to capture image into a LImage object with camera APIs, take Hik camera as an example.</p>
<blockquote class="doxtable">
<p><b>Source code (C#):</b> csharpdemo/CSharpHikCam</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">LImage</a> </p>
</blockquote>
<ol type="1">
<li>Install driver of Hik camera.</li>
<li>Open MVS to fetch the serial number of your camera, fill it into the text edit on the right.</li>
<li>Click <b>Start</b> button, open the camera.</li>
<li>Click <b>Run (Continues Trigger)</b>, switch to continues trigger mode. It will update then display images captured by camera continuously.</li>
<li>Click <b>Snap (Soft Trigger)</b>, switch to soft-trigger mode. It snap one frame then display on UI.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_pat"></a>
Template Matching</h1>
<p>Demonstrate template matching with sub-pixel precision.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCPat<br  />
 <b>Source code (Qt):</b> qtdemo/QtPat<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpPat<br  />
 <b>Image files:</b> sourceImg.png</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_rect_region.html">LRectRegion</a>, <a class="el" href="interface_l_p_v_pat_lib_1_1_i_l_match.html">LMatch</a>, <a class="el" href="interface_l_p_v_pat_lib_1_1_i_l_match_results.html">LMatchResults</a> </p>
</blockquote>
<p><a href="t02_12_pat.png"><img src="t02_12_pat.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>Click <b>Learn</b> button, learn template from current image and region.</li>
<li>Modify the <b>Angle</b> and <b>Scale</b> parameter as required.</li>
<li>Modify <b>Grayscale Match Weight</b> to adjust the weight of gray value similarity in the evaluation score.</li>
<li>Click <b>Match in ROI</b> button, do pattern matching in current region.</li>
<li>The result shows in the table below, including the center positions, angles, scales and scores.</li>
<li>Select one to highlight it on the canvas. <br  />
 <br  />
</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_blob"></a>
Blob Analysis</h1>
<p>Demonstrate blob analysis, either in grayscale or color mode.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCBlob<br  />
 <b>Source code (Qt):</b> qtdemo/QtBlob<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpBlob<br  />
 <b>Image files:</b> rou.jpg, smile.png, cat.png</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_blob_lib_1_1_i_l_blob_analysis.html">LBlobAnalysis</a>, <a class="el" href="interface_l_p_v_blob_lib_1_1_i_l_blob_filter.html">LBlobFilter</a>, <a class="el" href="interface_l_p_v_blob_lib_1_1_i_l_blob_results.html">LBlobResults</a>, <a class="el" href="interface_l_p_v_blob_lib_1_1_i_l_blob.html">LBlob</a> </p>
</blockquote>
<p><a href="t02_03_blob.png"><img src="t02_03_blob.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.<ul>
<li>The <b>Mode</b> changes to <em>Grayscale</em> or <em>Color</em>, according to the image format.</li>
</ul>
</li>
<li>Select <b>Threshold</b> to use the proper threshold mode:<ul>
<li><b>0 Custom</b>: use the input lower and upper threshold range.</li>
<li><b>1 Global Adaptive</b>: use the auto-generated adaptive threshold based on the entire image and specified <b>Polarity</b>, then revised by <b>Bias</b>.</li>
<li><b>2 Local Adaptive</b>: use the auto-generated adaptive threshold based on the local window and specified <b>Polarity</b>, then revised by <b>Bias</b>.</li>
</ul>
</li>
<li>Modify <b>Soft Threshold</b> to non-zero value to enable soft thresholding.</li>
<li>Click <b>Preview</b> to check the thresholding result.</li>
<li>Or, you can click <b>Select Blob Range - Click on Canvas</b> button, then click on the canvas where blob object is. It will generate a custom threshold range based on the selected pixels.</li>
<li>Change <b>Max Count</b> for multiple instances detection.</li>
<li>Select <b>Sort by</b> to use the proper method to sort all blob candidates, the top ones are reported as final results.</li>
<li>Click <b>Detect</b> to run the blob analysis.</li>
<li>The table shows all valid results, including their center positions, area, perimeter, circularity and aspect ratio.</li>
<li>Select one to highlight it on the canvas.</li>
<li>Check and modify the ranges to filter the required properties.</li>
<li>Click <b>Set Limitation (Based on Current Blob)</b> to generate filters' lower and upper bound based on current selected blob object.</li>
<li>Click <b>Re-filter</b> to apply filters on the blob results.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_imgproc"></a>
Image Processing</h1>
<p>Demonstrate the common image processing operations.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCImgProc<br  />
 <b>Source code (Qt):</b> qtdemo/QtImgProc<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpImgProc<br  />
</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_threshold.html">LImageThreshold</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_arithm.html">LImageArithm</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_filter.html">LImageFilter</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_edge_filter.html">LEdgeFilter</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_morph.html">LImageMorph</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_stats.html">LImageStats</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_histogram.html">LHistogram</a> </p>
</blockquote>
<p><a href="t02_10_imgproc.png"><img src="t02_10_imgproc.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>The demo application builds histogram of the image and display it on the right canvas.</li>
<li>The demo application calculates the image and the histogram's statistic metrics in the pop-up windows.</li>
<li>Click the image processing buttons below to do specified processing on the image.</li>
<li>The result image shows on the left canvas.</li>
<li>Click <b>Show Original</b> to display the original image. <br  />
 <br  />
 <br  />
</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_line"></a>
Line Detection</h1>
<p>Demonstrate line detection with sub-pixel precision.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCLine<br  />
 <b>Source code (Qt):</b> qtdemo/QtLine<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpLine<br  />
 <b>Image files:</b> nline_many.png</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_rot_rect_region.html">LRotRectRegion</a>, <a class="el" href="interface_l_p_v_locate_lib_1_1_i_l_line_detector.html">LLineDetector</a>, <a class="el" href="interface_l_p_v_locate_lib_1_1_i_l_line_results.html">LLineResults</a> </p>
</blockquote>
<p><a href="t02_11_line.png"><img src="t02_11_line.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>Drag the handles of the region, move, rotate or resize the rotated rectangle region.</li>
<li>Select <b>Polarity</b> to use the proper polarity of the line edge:<ul>
<li><b>0 Dark to Light</b>: The edge is from black(dark) pixels to white(light).</li>
<li><b>1 Light to Dark</b>: The edge is from white(light) pixels to black(dark).</li>
<li><b>2 Either</b>: Either polarity is acceptable.</li>
</ul>
</li>
<li>Select <b>Find</b> to use the proper find-by strategy for the line selection:<ul>
<li><b>0 Best</b>: The lines with best scores.</li>
<li><b>1 First</b>: The first lines.</li>
<li><b>2 Last</b>: The last lines.</li>
</ul>
</li>
<li>Modify <b>Accept Score</b> to filter false results with bad scores</li>
<li>Change <b>Max Count</b> for multiple instances detection.</li>
<li>Click <b>Detect</b> to do line detection.</li>
<li>The table shows all valid results, including their middle points' positions and angles.</li>
<li>Select one to highlight it on the canvas.</li>
<li>The chart shows the score distribution along the region's direction. It's useful for determining a proper accept score.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_circle"></a>
Circle Detection</h1>
<p>Demonstrate circle detection with sub-pixel precision.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCCircle<br  />
 <b>Source code (Qt):</b> qtdemo/QtCircle<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpCircle<br  />
 <b>Image files:</b> half_arc_1.png</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_annulus_region.html">LAnnulusRegion</a>, <a class="el" href="interface_l_p_v_locate_lib_1_1_i_l_circle_detector.html">LCircleDetector</a>, <a class="el" href="interface_l_p_v_locate_lib_1_1_i_l_circle_results.html">LCircleResults</a> </p>
</blockquote>
<p><a href="t02_06_circle.png"><img src="t02_06_circle.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>Drag the handles of the region, move or resize the annulus region, put its center near the center of the circle.</li>
<li>Select <b>Polarity</b> to use the proper polarity of the circle edge:<ul>
<li><b>0 Dark to Light</b>: The edge is from black(dark) pixels to white(light).</li>
<li><b>1 Light to Dark</b>: The edge is from white(light) pixels to black(dark).</li>
<li><b>2 Either</b>: Either polarity is acceptable.</li>
</ul>
</li>
<li>Select <b>Find</b> to use the proper find-by strategy for the circle selection:<ul>
<li><b>0 Best</b>: The circles with best scores.</li>
<li><b>1 Smallest</b>: The smallest circles.</li>
<li><b>2 Largest</b>: The largest circles.</li>
</ul>
</li>
<li>Modify <b>Accept Score</b> to filter false results with bad scores</li>
<li>Change <b>Max Count</b> for multiple instances detection.</li>
<li>Click <b>Detect</b> to do circle detection.</li>
<li>The table shows all valid results, including their center positions and radius.</li>
<li>Select one to highlight it on the canvas.</li>
<li>The chart shows the score distribution along the region's direction. It's useful for determining a proper accept score.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_path"></a>
Path Detection</h1>
<p>Demonstrate path detection.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCPath<br  />
 <b>Source code (Qt):</b> qtdemo/QtPath<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpPath<br  />
 <b>Image files:</b> nline_many.png, leadcut.png</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_rot_rect_region.html">LRotRectRegion</a>, <a class="el" href="interface_l_p_v_locate_x_lib_1_1_i_l_path_detector.html">LPathDetector</a>, <a class="el" href="interface_l_p_v_locate_x_lib_1_1_i_l_path_results.html">LPathResults</a> </p>
</blockquote>
<p><a href="t02_14_path.png"><img src="t02_14_path.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>Drag the handles of the region, move, rotate or resize the rotated rectangle region.</li>
<li>Select the proper <b>Polarity</b>. to find the correct type of path:<ul>
<li><b>0 Black on White</b>: Black(dark) path on the white(light) background.</li>
<li><b>1 White on Black</b>: White(light) path on the black(dark) background.</li>
</ul>
</li>
<li>Change the score thresholds to a proper value:<ul>
<li><b>Score</b>: The absolute accept score.</li>
<li><b>Relative Score</b>: The relative accept score, computed using the current and the next result candidate or background pixels.</li>
</ul>
</li>
<li>Change <b>Path Width</b> to merge/separate nearby paths in multiple instances detection.</li>
<li>Change <b>Straightness</b> , it's used to controls the trend of the path.</li>
<li>Change <b>Max Count</b> for multiple instances detection.</li>
<li>Click <b>Detect</b> to do path detection.</li>
<li>The table shows all valid results, including their start position and scores.</li>
<li>Select one to highlight it on the canvas.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_contour"></a>
Contour Detection</h1>
<p>Demonstrate contour detection with sub-pixel precision.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCContour<br  />
 <b>Source code (Qt):</b> qtdemo/QtContour<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpContour<br  />
 <b>Image files:</b> rectwithhole.png</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_rot_rect_region.html">LRotRectRegion</a>, <a class="el" href="interface_l_p_v_locate_x_lib_1_1_i_l_contour_detector.html">LContourDetector</a>, <a class="el" href="interface_l_p_v_locate_x_lib_1_1_i_l_contour_results.html">LContourResults</a> </p>
</blockquote>
<p><a href="t02_15_contour.png"><img src="t02_15_contour.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>Drag the handles of the region, move, rotate or resize the rotated rectangle region.</li>
<li>Change the <b>Connect Tolerance</b> and <b>Kernel Size</b> to the proper value.</li>
<li>Change the rejection and filtering thresholds<ul>
<li><b>Reject Short</b> and <b>Reject Weak</b>: The absolute thresholds used to reject very Short-OR-Weak contours.</li>
<li><b>Filter Short</b> and <b>Filter Weak</b>: The relative threshold used to filter the Short-And-Weak contours, compared with the longest/strongest contour in the candidates.</li>
</ul>
</li>
<li>Click <b>Detect</b> to do contour detection.</li>
<li>The table shows all valid results, including their average magnitude, length and scores.</li>
<li>Select one to highlight it on the canvas.</li>
<li>Select the proper <b>Polarity</b> then click <b>Detect With Direction</b> to do detection with direction filtering:<ul>
<li><b>0 Dark to Light</b>: The edge is from black(dark) pixels to white(light).</li>
<li><b>1 Light to Dark</b>: The edge is from white(light) pixels to black(dark).</li>
<li><b>2 Either</b>: Either polarity is acceptable.</li>
</ul>
</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_crossmark"></a>
Cross Mark Detection</h1>
<p>Demonstrate cross mark detection with sub-pixel precision.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCCrossMark<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpCrossMark<br  />
 <b>Image files:</b> cross_white.png, cross_edge.png, cross_12.png</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_rect_region.html">LRectRegion</a>, <a class="el" href="interface_l_p_v_locate_x_lib_1_1_i_l_cross_mark_detector.html">LCrossMarkDetector</a>, <a class="el" href="interface_l_p_v_locate_x_lib_1_1_i_l_cross_mark_results.html">LCrossMarkResults</a> </p>
</blockquote>
<p><a href="t02_20_crossmark.png"><img src="t02_20_crossmark.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>Drag the handles of the region, move or resize the rectangle region.</li>
<li>Check <b>Use Auto-Threshold</b> to enable using auto-thresholding, or set the proper <b>Mark Range</b> for custom-thresholding, to locate the cross mark candidate positions.</li>
<li>Choose the proper <b>Polarity</b> to precisely locate the two cross lines:<ul>
<li><b>0 Dark to Light</b> : by the line edges from black(dark) pixels to white(light).</li>
<li><b>1 Light to Dark</b> ：by the line edges from white(light) pixels to black(dark).</li>
<li><b>2 Dark on Light</b> ：by the black(dark) pixels on the line out of white(light) background.</li>
<li><b>3 Light on Dark</b> ：by the white(light) pixels on the line out of black(dark) background.</li>
</ul>
</li>
<li>Set the proper <b>Size Range</b> and <b>Width</b> , it helps filter the false detections</li>
<li>Click <b>Detect</b> or <b>Detect in ROI</b> button to do detection. The table shows all valid results and their center positions.</li>
<li>Select one to highlight it on the canvas.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_gauge"></a>
Gauging</h1>
<p>Demonstrate the inspection using gauge tools for various shapes.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCGauge<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpGauge<br  />
 <b>Image files:</b> cutkerf.png, leadcut.png</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_gauge_lib_1_1_i_l_line_gauge.html">LLineGauge</a> <a class="el" href="interface_l_p_v_gauge_lib_1_1_i_l_circle_gauge.html">LCircleGauge</a> <a class="el" href="interface_l_p_v_gauge_lib_1_1_i_l_arc_gauge.html">LArcGauge</a> </p>
</blockquote>
<p><a href="t02_19_gauge.png"><img src="t02_19_gauge.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>Click <b>Reset ROI</b> button, reset region's placement according to current image size.</li>
<li>Select the required gauge type, for example, line gauge.</li>
<li>Select <b>Polarity</b> to use the proper polarity of the line edge:<ul>
<li><b>0 Dark to Light</b>: The edge is from black(dark) pixels to white(light).</li>
<li><b>1 Light to Dark</b>: The edge is from white(light) pixels to black(dark).</li>
<li><b>2 Either Edge</b>: Either edge polarity is acceptable.</li>
<li><b>3 Black on White</b>: This is a black(dark) object on white(light) background.</li>
<li><b>4 White on Black</b>: This is a white(light) object on black(dark) background.</li>
<li><b>5 Either Object</b>: Either object polarity is acceptable.</li>
</ul>
</li>
<li>Change the size and interval of the sample regions.</li>
<li>Click <b>Detect</b> button to do gauge inspection.</li>
<li>The result is shown in the result panel as text, for lines, it shows the position of its middle point and the angle.</li>
<li>The chart shows the score distribution along the region's direction. It's useful for determining a proper accept score.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_calib"></a>
Calibration</h1>
<p>Demonstrate the camera calibration, including n-points, pin-hole, FFD camera models using different types of calibration boards.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCCalib<br  />
 <b>Source code (Qt):</b> qtdemo/QtCalib<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpCalib<br  />
 <b>Image files:</b> chessboard.png, circlegrid.png, distcharuco.jpg</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_calib_lib_1_1_i_l_calib_n_points.html">LCalibNPoints</a>, <a class="el" href="interface_l_p_v_calib_lib_1_1_i_l_calib_pin_hole.html">LCalibPinHole</a>, <a class="el" href="interface_l_p_v_calib_lib_1_1_i_l_calib_f_f_d.html">LCalibFFD</a>, <a class="el" href="interface_l_p_v_calib_lib_1_1_i_l_calib_custom.html">LCalibCustom</a>, <a class="el" href="interface_l_p_v_calib_lib_1_1_i_l_calib_board.html">LCalibBoard</a>, <a class="el" href="interface_l_p_v_calib_lib_1_1_i_l_calib_point_pairs.html">LCalibPointPairs</a> </p>
</blockquote>
<p><a href="t02_04_calib.png"><img src="t02_04_calib.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Choose the proper calibration board type and click:<ul>
<li><b>Chessboard</b>: open the chessboard image, change the <b>Grid Size</b> and <b>Square Size</b></li>
<li><b>Circle Grid</b>: open the circle grid image, change the <b>Grid Size</b> and <b>Square Size</b></li>
<li><b>Distributed Charuco</b>: open the dist-charuco image, change the <b>Square Size</b></li>
</ul>
</li>
<li>Check <b>Auto Remove Bad</b> to let the board detection method remove bad corners.</li>
<li>Click <b>Detect</b> to detect the calibration board, generate the image and world point pairs.</li>
<li>Choose the proper calibration model:<ul>
<li><b>NPoints</b>: choose the proper transformation type.</li>
<li><b>PinHole</b>: you may add multi-view points, click the button to add the current image pairs as multi-view points</li>
<li><b>FFD</b>: modify the grid size, bigger size output more precise optimization, but slower.</li>
<li><b>Custom</b>: define custom calibration.</li>
</ul>
</li>
<li>Click <b>Calibrate</b> to do calibration</li>
<li>Click <b>Save</b> to save the calibration to file.</li>
<li>Click <b>Load</b> to load the calibration from file.</li>
<li>Click <b>Reset</b> to reset the calibration.</li>
<li>Choose the proper fix mode then click <b>Fix Image</b>, the fixed image shows on the canvas.</li>
<li>Move the cursor on the canvas will show the pixel under the cursor and its corresponding world position.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_camarray"></a>
Camera Array and Image Stitching</h1>
<p>Demonstrate the camera array calibration and image stitching.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCCamArray<br  />
 <b>Source code (Qt):</b> qtdemo/QtCamArray<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpCamArray<br  />
 <b>Image folders:</b> camera_array</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_calib_lib_1_1_i_l_camera_array.html">LCameraArray</a>, <a class="el" href="interface_l_p_v_calib_lib_1_1_i_l_calib_board.html">LCalibBoard</a> </p>
</blockquote>
<p><a href="t02_05_camarray.png"><img src="t02_05_camarray.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b>, navigate and select the camera_array folder.</li>
<li>Modify <b>Square Size</b> and choose the proper calibration model.</li>
<li>Click <b>Calibrate</b> to do calibration of the loaded camera array.</li>
<li>Click <b>Image Stitching</b> to load the poker images then do stitching.</li>
<li>The upper two canvases show the original two images of the camera array, the lower canvas shows the stitching result image.</li>
<li>Move the cursor on the upper two or the lower canvas will show the pixel under the cursor in that image and its corresponding world position.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_geom"></a>
Geometry</h1>
<p>Demonstrate geometry module, including intersection calculation, gauging, fitting, etc.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCGeom<br  />
 <b>Source code (Qt):</b> qtdemo/QtGeom<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpGeom<br  />
</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_geom_lib_1_1_i_l_point.html">LPoint</a>, <a class="el" href="interface_l_p_v_geom_lib_1_1_i_l_line.html">LLine</a>, <a class="el" href="interface_l_p_v_geom_lib_1_1_i_l_circle.html">LCircle</a>, <a class="el" href="interface_l_p_v_geom_lib_1_1_i_l_points.html">LPoints</a>, <a class="el" href="interface_l_p_v_geom_lib_1_1_i_l_rect.html">LRect</a>, <a class="el" href="interface_l_p_v_geom_lib_1_1_i_l_polygon.html">LPolygon</a> </p>
</blockquote>
<p><a href="t02_08_geometry1.png"><img src="t02_08_geometry1.png" alt="" style="height: 200px;" class="inline"/> </a> <a href="t02_08_geometry2.png"><img src="t02_08_geometry2.png" alt="" style="height: 200px;" class="inline"/> </a> <a href="t02_08_geometry3.png"><img src="t02_08_geometry3.png" alt="" style="height: 200px;" class="inline"/> </a> <a href="t02_08_geometry4.png"><img src="t02_08_geometry4.png" alt="" style="height: 200px;" class="inline"/> </a></p>
<p><br  />
</p>
<h1><a class="anchor" id="demo_barcode"></a>
Barcode</h1>
<p>Demonstrate 1D/2D barcode detection and quality verification.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCBarcode<br  />
 <b>Source code (Qt):</b> qtdemo/QtBarcode<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpBarcode<br  />
 <b>Image files:</b> barcode_code39.png, barcode_code128.png, barcode_datamatrix.png, barcode_ean13.png, barcode_i25.png, barcode_qr.png</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_barcode_lib_1_1_i_l_barcode_detector.html">LBarcodeDetector</a>, <a class="el" href="interface_l_p_v_barcode_lib_1_1_i_l_barcode_results.html">LBarcodeResults</a>, <a class="el" href="interface_l_p_v_barcode_lib_1_1_i_l_barcode_result.html">LBarcodeResult</a> </p>
</blockquote>
<p><a href="t02_02_barcode.png"><img src="t02_02_barcode.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>Check the required 1D barcode types or <b>All 1D Barcode</b> for 1D barcode detection.</li>
<li>Check the required 2D barcode types or <b>All 2D Barcode</b> for 2D barcode detection.</li>
<li>Check <b>Quality Verify</b> for barcode quality verification.</li>
<li>Change <b>Max Count</b> for multiple instances detection.</li>
<li>Click <b>Detect</b> to do the detection and verification.</li>
<li>The table shows all valid results, including their center positions, angles, quality gradings and data.</li>
<li>Select one to highlight it on the canvas.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_display"></a>
Display Control</h1>
<p>Demonstrate the display control.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCDisplay<br  />
 <b>Source code (Qt):</b> qtdemo/QtDisplay<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpDisplay<br  />
</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_display_lib_1_1_i_l_display.html">LDisplay</a> </p>
</blockquote>
<p><a href="t02_07_displayctrl.png"><img src="t02_07_displayctrl.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Load Image</b> button, load image from file.</li>
<li>Select region type, and click <b>Add</b> to add some random regions to the display control.</li>
<li>Click <b>Reset</b> to remove all regions.</li>
<li>Select shape type, and click <b>Add</b> to add some random shapes to the display control.</li>
<li>Click <b>Reset</b> to remove all shapes.</li>
<li>Click <b>Open Display Dialog</b> to open a new display control in a pop-up dialog.</li>
<li>Drag the image to move it, use wheel to zoom in or out.</li>
<li>Click <b>Fit Window</b> to fit the image size to the current window size.</li>
<li>Click <b>Fit a Random Object</b> to move the viewport to a random region or shape, then zoom in or out to fit the current window size.</li>
<li>Click <b>Reset All</b> to remove all regions and shapes.</li>
<li>RMC the display control, pop-up the context menu.</li>
<li>Click <b>Save</b> to save the current image to file.</li>
<li>Click <b>Save Window</b> to save the screen-shot of the current window to file.</li>
</ol>
<p><br  />
</p>
<h1><a class="anchor" id="demo_ibservice"></a>
Connect to IntelliBlink Service</h1>
<p>Demonstrate how to integrate with and make use of powerful IntelliBlink tasks.</p>
<blockquote class="doxtable">
<p><b>Source code (C++):</b> mfcdemo/MFCIBService<br  />
 <b>Source code (Qt):</b> qtdemo/QtIBService<br  />
 <b>Source code (C#):</b> csharpdemo/CSharpIBService<br  />
 <b>Image folders:</b> exame_chip_1, exame_chip_2</p>
<p><b>Related classes:</b> <a class="el" href="interface_l_p_v_i_b_lib_1_1_i_l_i_b_service.html">LIBService</a>, <a class="el" href="interface_l_p_v_i_b_lib_1_1_i_l_i_b_algo_result.html">LIBAlgoResult</a>, <a class="el" href="interface_l_p_v_i_b_lib_1_1_i_l_i_b_data.html">LIBData</a>, <a class="el" href="interface_l_p_v_i_b_lib_1_1_i_l_i_b_algo_config.html">LIBAlgoConfig</a>, <a class="el" href="interface_l_p_v_pat_lib_1_1_i_l_match.html">LMatch</a> </p>
</blockquote>
<p><a href="t02_09_ibservice.png"><img src="t02_09_ibservice.png" alt="" style="float: right; height: 200px; margin-left: 20px;" class="inline"/> </a></p>
<ol type="1">
<li>Click <b>Select IB Service</b>, navigate and select the folder where IntelliBlink is installed.</li>
<li>Wait for the demo application to connect to the IntelliBlink engine, it will pop up a successful message box when it's done.</li>
<li>Click <b>Load IB Task</b>, select the folder of example task and images.</li>
<li>The demo application does template matching to find all object on the source image and shows the result list.</li>
<li>Select one matching result in the list.</li>
<li>The demo application generates region from the matching result, then execute IntelliBlink task on the reduced image.</li>
<li>The execution time and results of the task are shown on the canvas or on the right panel.</li>
<li>Click <b>Refresh</b> to reload the task's parameters from the IntelliBlink engine.</li>
<li>Modify the parameters in the input editor.</li>
<li>Drag the handles of the region, move or resize the region in the task.</li>
<li>Click <b>Apply</b> to apply the modified parameters to the IntelliBlink engine.</li>
</ol>
<p><br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
© 2023 <a href="http://www.hzleaper.com/">Hangzhou Leaper Tech. Ltd.</a>
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
